### Анализ производительности

После включения визуального алгоритма бот не работает.  Скорость реакции очень низкая и 
следования не происходит. Необходимо провести анализ и понять почему происходят такие задержки. 

Причины может быть две:
* Задержки при получении кадра с камеры
* Задержки при вычислении позиции линии

#### Тесты алгоритма
* C заглушкой вместо датчиков dt=0.435551 ms.
* С измерением IR датчиков dt=2.590298 ms. Одно ядро 40-60%. Остальные
* C получением видеофрейма dt=36.691684 ms. Одно ядро на 100% загружено. Расчет _calculateValuesByFrame включен
* C получением видеофрейма dt=34.691684 ms. Одно ядро на 21% загружено. Расчет _calculateValuesByFrame заглушен. cv2.VideoCapture(0), _capture.set(3, 640), _capture.set(4, 480) 

По умолчанию формируется фрейм 640x480
Уменьшение размера захвата не приводит к уменьшению времени захвата dt=34.680095; frame=160x120
Увеличение размера сильно замедляет dt=177.462144; frame=1024x768

Итого получаем 1000/34 = 29FPS

Нужен отдельный тест по производительности чтения камеры. Можно попробовать сделать на Java. Также можно попробовать читать фреймы без OpenCV

https://forums.raspberrypi.com/viewtopic.php?p=1283780&hilit=hermannsw+opencv#p1283755
https://gist.github.com/CarlosGS/b8462a8a1cb69f55d8356cbb0f3a4d63
https://proglib.io/p/opencv-sravnivaem-skorost-koda-c-i-python-na-raspberry-pi-stereozrenie-2020-02-06
https://raspberrypi.stackexchange.com/questions/58871/pi-camera-v2-fast-full-sensor-capture-mode-with-downsampling

На самом деле, в Python можно использовать способ захвата, аналогичный применяемому в коде на C++ – передача видео через pipe шустрой утилитой raspividyuv. 
Второй подход – решение, предложенное автором PiCamera в одном из ответов на Raspberry.stackexchange.